/**
 * üîß FASE 0 - TAREFA 0.1: Corrigir associa√ß√µes HPO-doen√ßa no SQLite
 * üéØ OBJETIVO: Importar as 50.024 associa√ß√µes que est√£o zeradas no SQLite
 * üìä META: MySQL 50.024 = SQLite 50.024 (100% sincroniza√ß√£o)
 * üõ°Ô∏è ESTRAT√âGIA: Manter MySQL como fonte verdade, sincronizar SQLite
 */

const { PrismaClient } = require('@prisma/client');
const mysql = require('mysql2/promise');

const prisma = new PrismaClient();

async function tarefa01_corrigirAssociacoesHpoDoenca() {
    console.log('üîß FASE 0 - TAREFA 0.1: CORRIGIR ASSOCIA√á√ïES HPO-DOEN√áA NO SQLITE');
    console.log('=' + '='.repeat(80));
    console.log('üéØ OBJETIVO: Importar 50.024 associa√ß√µes zeradas no SQLite');
    console.log('üìä META: MySQL 50.024 = SQLite 50.024 (100% sincroniza√ß√£o)');
    console.log('üõ°Ô∏è ESTRAT√âGIA: MySQL como fonte verdade ‚Üí sincronizar SQLite');
    
    let mysqlConn;
    
    try {
        // 1. CONECTAR AO MYSQL
        mysqlConn = await mysql.createConnection({
            host: 'localhost',
            user: 'root',
            password: '',
            database: 'cplp_raras'
        });
        
        console.log('‚úÖ Conex√£o MySQL estabelecida');
        
        // 2. VERIFICAR ESTADO ATUAL
        console.log('\nüìä VERIFICANDO ESTADO ATUAL...');
        
        const [mysqlCount] = await mysqlConn.query('SELECT COUNT(*) as count FROM hpo_disease_associations');
        const sqliteCount = await prisma.hpoDiseasAssociation.count();
        
        console.log(`üìã MySQL hpo_disease_associations: ${mysqlCount[0].count.toLocaleString()}`);
        console.log(`üìã SQLite hpoDiseasAssociation: ${sqliteCount.toLocaleString()}`);
        
        const deficit = mysqlCount[0].count - sqliteCount;
        console.log(`‚ùå D√©ficit SQLite: ${deficit.toLocaleString()} associa√ß√µes`);
        
        if (deficit === 0) {
            console.log('‚úÖ TAREFA J√Å CONCLU√çDA: Associa√ß√µes j√° sincronizadas!');
            return;
        }
        
        // 3. LIMPAR ASSOCIA√á√ïES EXISTENTES NO SQLITE
        console.log('\nüßπ LIMPANDO ASSOCIA√á√ïES EXISTENTES NO SQLITE...');
        await prisma.hpoDiseasAssociation.deleteMany({});
        console.log('‚úÖ Associa√ß√µes SQLite removidas');
        
        // 4. MAPEAR HPO TERMS
        console.log('\nüó∫Ô∏è  MAPEANDO HPO TERMS...');
        
        const [mysqlHpoTerms] = await mysqlConn.query(`
            SELECT id as mysql_id, hpoId as hpo_code 
            FROM hpo_terms 
            WHERE hpoId IS NOT NULL
        `);
        
        const sqliteHpoTerms = await prisma.hpoTerm.findMany({
            select: { id: true, hpo_id: true }
        });
        
        const mysqlHpoMap = new Map();
        mysqlHpoTerms.forEach(hpo => {
            mysqlHpoMap.set(hpo.mysql_id, hpo.hpo_code);
        });
        
        const sqliteHpoMap = new Map();
        sqliteHpoTerms.forEach(hpo => {
            sqliteHpoMap.set(hpo.hpo_id, hpo.id);
        });
        
        console.log(`üìä MySQL HPO Terms: ${mysqlHpoMap.size.toLocaleString()}`);
        console.log(`üìä SQLite HPO Terms: ${sqliteHpoMap.size.toLocaleString()}`);
        
        // 5. MAPEAR DISEASES
        console.log('\nüó∫Ô∏è  MAPEANDO DISEASES...');
        
        const sqliteDiseases = await prisma.rareDisease.findMany({
            select: { id: true, orphacode: true }
        });
        
        const diseaseMap = new Map();
        sqliteDiseases.forEach(disease => {
            if (disease.orphacode) {
                diseaseMap.set(`ORPHA:${disease.orphacode}`, disease.id);
            }
        });
        
        console.log(`üìä SQLite Diseases mapeadas: ${diseaseMap.size.toLocaleString()}`);
        
        // 6. BUSCAR MAPEAMENTOS OMIM ‚Üí ORPHA
        console.log('\nüîç BUSCANDO MAPEAMENTOS OMIM ‚Üí ORPHA...');
        
        const [omimMappings] = await mysqlConn.query(`
            SELECT 
                em.source_code,
                od.orpha_code
            FROM orpha_external_mappings em
            JOIN orpha_diseases od ON em.orpha_disease_id = od.id
            WHERE em.source_system = 'OMIM'
        `);
        
        const omimToOrphaMap = new Map();
        omimMappings.forEach(mapping => {
            omimToOrphaMap.set(`OMIM:${mapping.source_code}`, `ORPHA:${mapping.orpha_code}`);
        });
        
        console.log(`üìä Mapeamentos OMIM ‚Üí ORPHA: ${omimToOrphaMap.size.toLocaleString()}`);
        
        // 7. PROCESSAR TODAS AS ASSOCIA√á√ïES DO MYSQL
        console.log('\nüîÑ PROCESSANDO TODAS AS ASSOCIA√á√ïES DO MYSQL...');
        
        const [allAssociations] = await mysqlConn.query(`
            SELECT 
                hpoTermId as mysql_hpo_id,
                diseaseId as disease_code,
                evidence,
                frequencyTerm as frequency
            FROM hpo_disease_associations
            ORDER BY id
        `);
        
        console.log(`üìä Total associa√ß√µes MySQL: ${allAssociations.length.toLocaleString()}`);
        
        let processadas = 0;
        let importadas = 0;
        let puladasHpo = 0;
        let puladasDisease = 0;
        const batchSize = 2000;
        const associationBatch = [];
        
        for (let assoc of allAssociations) {
            processadas++;
            
            try {
                // Mapear HPO
                const hpoCode = mysqlHpoMap.get(assoc.mysql_hpo_id);
                const sqliteHpoId = hpoCode ? sqliteHpoMap.get(hpoCode) : null;
                
                if (!sqliteHpoId) {
                    puladasHpo++;
                    continue;
                }
                
                // Mapear Disease
                let diseaseCode = assoc.disease_code;
                let sqliteDiseaseId = null;
                
                // Tentar mapeamento direto ORPHA
                if (diseaseCode.startsWith('ORPHA:')) {
                    sqliteDiseaseId = diseaseMap.get(diseaseCode);
                }
                // Tentar mapeamento OMIM ‚Üí ORPHA
                else if (diseaseCode.startsWith('OMIM:')) {
                    const orphaCode = omimToOrphaMap.get(diseaseCode);
                    if (orphaCode) {
                        sqliteDiseaseId = diseaseMap.get(orphaCode);
                    }
                }
                
                if (!sqliteDiseaseId) {
                    puladasDisease++;
                    continue;
                }
                
                // Adicionar ao batch
                associationBatch.push({
                    hpo_id: sqliteHpoId,
                    disease_id: sqliteDiseaseId,
                    evidence: String(assoc.evidence || ''),
                    frequency: String(assoc.frequency || ''),
                    source: diseaseCode.startsWith('ORPHA:') ? 'ORPHA_DIRECT' : 'OMIM_MAPPED'
                });
                
                // Processar batch
                if (associationBatch.length >= batchSize) {
                    await prisma.hpoDiseasAssociation.createMany({
                        data: associationBatch,
                        skipDuplicates: true
                    });
                    
                    importadas += associationBatch.length;
                    associationBatch.length = 0;
                    
                    if (importadas % 10000 === 0) {
                        const percent = ((processadas / allAssociations.length) * 100).toFixed(1);
                        console.log(`      üîÑ Processadas: ${processadas.toLocaleString()} (${percent}%) | Importadas: ${importadas.toLocaleString()}`);
                    }
                }
                
            } catch (error) {
                console.log(`   ‚ö†Ô∏è  Erro processando associa√ß√£o: ${error.message.substring(0, 50)}...`);
            }
        }
        
        // Processar √∫ltimo batch
        if (associationBatch.length > 0) {
            await prisma.hpoDiseasAssociation.createMany({
                data: associationBatch,
                skipDuplicates: true
            });
            importadas += associationBatch.length;
        }
        
        // 8. VERIFICA√á√ÉO FINAL
        console.log('\nüìä RESULTADO FINAL DA TAREFA 0.1:');
        console.log('=' + '='.repeat(60));
        
        const finalSqliteCount = await prisma.hpoDiseasAssociation.count();
        const finalMysqlCount = (await mysqlConn.query('SELECT COUNT(*) as count FROM hpo_disease_associations'))[0][0].count;
        
        console.log(`üìä ESTAT√çSTICAS DE PROCESSAMENTO:`);
        console.log(`   üîÑ Total processadas: ${processadas.toLocaleString()}`);
        console.log(`   ‚úÖ Importadas: ${importadas.toLocaleString()}`);
        console.log(`   ‚ùå Puladas (HPO): ${puladasHpo.toLocaleString()}`);
        console.log(`   ‚ùå Puladas (Disease): ${puladasDisease.toLocaleString()}`);
        
        console.log(`\nüìä CONTAGENS FINAIS:`);
        console.log(`   üóÑÔ∏è  MySQL: ${finalMysqlCount.toLocaleString()}`);
        console.log(`   üóÑÔ∏è  SQLite: ${finalSqliteCount.toLocaleString()}`);
        
        const syncPercent = ((finalSqliteCount / finalMysqlCount) * 100).toFixed(1);
        console.log(`   üìà Sincroniza√ß√£o: ${syncPercent}%`);
        
        // 9. AVALIA√á√ÉO DE SUCESSO
        console.log('\nüéØ AVALIA√á√ÉO DE SUCESSO DA TAREFA 0.1:');
        console.log('=' + '='.repeat(60));
        
        if (syncPercent >= 99.0) {
            console.log('üéâüéâüéâ TAREFA 0.1 CONCLU√çDA COM SUCESSO! üéâüéâüéâ');
            console.log('‚úÖ Sincroniza√ß√£o ‚â• 99% alcan√ßada');
            console.log('‚úÖ Associa√ß√µes HPO-doen√ßa restauradas no SQLite');
            console.log('‚úÖ Pronto para TAREFA 0.2');
        } else if (syncPercent >= 90.0) {
            console.log('‚úÖ TAREFA 0.1 PARCIALMENTE CONCLU√çDA');
            console.log('‚ö†Ô∏è  Sincroniza√ß√£o 90-99% - Investigar lacunas');
            console.log('üí° Considerar ajustes antes da TAREFA 0.2');
        } else {
            console.log('‚ùå TAREFA 0.1 PRECISA DE ATEN√á√ÉO');
            console.log('üîß Sincroniza√ß√£o < 90% - Revisar mapeamentos');
            console.log('‚ö†Ô∏è  N√ÉO prosseguir para TAREFA 0.2 sem corrigir');
        }
        
        console.log('\nüìã RESUMO DA TAREFA 0.1:');
        console.log(`‚úÖ Estado inicial: SQLite 0 associa√ß√µes`);
        console.log(`‚úÖ Meta: ${finalMysqlCount.toLocaleString()} associa√ß√µes`);
        console.log(`‚úÖ Resultado: ${finalSqliteCount.toLocaleString()} associa√ß√µes (${syncPercent}%)`);
        console.log(`‚úÖ Status: ${syncPercent >= 99 ? 'CONCLU√çDA' : syncPercent >= 90 ? 'PARCIAL' : 'PENDENTE'}`);
        
    } catch (error) {
        console.error('üí• ERRO CR√çTICO na TAREFA 0.1:', error.message);
        console.error('üìã Stack trace:', error.stack);
        console.log('\n‚ùå TAREFA 0.1 FALHOU - N√£o prosseguir para pr√≥xima tarefa');
    } finally {
        if (mysqlConn) await mysqlConn.end();
        await prisma.$disconnect();
    }
}

// EXECUTAR TAREFA 0.1
tarefa01_corrigirAssociacoesHpoDoenca().then(() => {
    console.log('\nüèÅ TAREFA 0.1 FINALIZADA!');
    console.log('üìã Verifique o status antes de prosseguir para TAREFA 0.2');
}).catch(err => {
    console.error('üí• ERRO FINAL TAREFA 0.1:', err.message);
});
