const mysql = require('mysql2/promise');
const fs = require('fs');
const path = require('path');

// ConfiguraÃ§Ãµes do servidor remoto
const SERVER_CONFIG = {
    host: '200.144.254.4',
    user: 'filipe',
    password: 'IamSexyAndIKnowIt#2025(*',
    port: 3306,
    charset: 'utf8mb4'
};

async function connectToRemoteServer() {
    console.log('ğŸ”Œ CONECTANDO NO SERVIDOR REMOTO MySQL');
    console.log('â•'.repeat(60));
    console.log(`ğŸŒ Host: ${SERVER_CONFIG.host}`);
    console.log(`ğŸ‘¤ User: ${SERVER_CONFIG.user}`);
    console.log(`ğŸ”— Port: ${SERVER_CONFIG.port}`);
    
    try {
        // Conectar sem especificar database para listar todas
        const connection = await mysql.createConnection({
            host: SERVER_CONFIG.host,
            user: SERVER_CONFIG.user,
            password: SERVER_CONFIG.password,
            port: SERVER_CONFIG.port
        });
        
        console.log('âœ… Conectado com sucesso ao servidor!');
        return connection;
        
    } catch (error) {
        console.error('âŒ Erro ao conectar:', error.message);
        throw error;
    }
}

async function listDatabases(connection) {
    console.log('\nğŸ“Š LISTANDO DATABASES DISPONÃVEIS');
    console.log('â”€'.repeat(50));
    
    try {
        const [databases] = await connection.query('SHOW DATABASES');
        
        console.log(`ğŸ“¦ Encontradas ${databases.length} databases:`);
        databases.forEach((db, index) => {
            const dbName = Object.values(db)[0];
            console.log(`   ${index + 1}. ${dbName}`);
        });
        
        return databases.map(db => Object.values(db)[0]);
        
    } catch (error) {
        console.error('âŒ Erro ao listar databases:', error.message);
        throw error;
    }
}

async function analyzeDatabase(connection, dbName) {
    console.log(`\nğŸ” ANALISANDO DATABASE: ${dbName}`);
    console.log('â”€'.repeat(50));
    
    try {
        // Usar o database
        await connection.query(`USE \`${dbName}\``);
        
        // Listar tabelas
        const [tables] = await connection.query('SHOW TABLES');
        
        if (tables.length === 0) {
            console.log('âš ï¸  Database vazio (sem tabelas)');
            return { name: dbName, tables: [], totalRecords: 0 };
        }
        
        console.log(`ğŸ“‹ Encontradas ${tables.length} tabelas:`);
        
        const tableDetails = [];
        let totalRecords = 0;
        
        for (const table of tables) {
            const tableName = Object.values(table)[0];
            
            try {
                // Contar registros
                const [rows] = await connection.query(`SELECT COUNT(*) as count FROM \`${tableName}\``);
                const count = rows[0].count;
                totalRecords += count;
                
                console.log(`   ğŸ“Š ${tableName}: ${count.toLocaleString()} registros`);
                tableDetails.push({ name: tableName, count: count });
                
            } catch (err) {
                console.log(`   âŒ ${tableName}: ERRO - ${err.message}`);
                tableDetails.push({ name: tableName, count: 'ERRO', error: err.message });
            }
        }
        
        console.log(`ğŸ“ˆ Total de registros no database: ${totalRecords.toLocaleString()}`);
        
        return {
            name: dbName,
            tables: tableDetails,
            totalRecords: totalRecords
        };
        
    } catch (error) {
        console.error(`âŒ Erro ao analisar database ${dbName}:`, error.message);
        return { name: dbName, tables: [], totalRecords: 0, error: error.message };
    }
}

async function createMySQLDump(connection, dbName, outputPath) {
    console.log(`\nğŸ’¾ CRIANDO DUMP DO DATABASE: ${dbName}`);
    console.log('â”€'.repeat(50));
    
    try {
        // Usar o database
        await connection.query(`USE \`${dbName}\``);
        
        // Obter lista de tabelas
        const [tables] = await connection.query('SHOW TABLES');
        
        if (tables.length === 0) {
            console.log('âš ï¸  Database vazio - nenhum dump criado');
            return null;
        }
        
        let dumpContent = '';
        
        // Header do dump
        dumpContent += `-- MySQL Dump\n`;
        dumpContent += `-- Host: ${SERVER_CONFIG.host}\n`;
        dumpContent += `-- Database: ${dbName}\n`;
        dumpContent += `-- Date: ${new Date().toISOString()}\n`;
        dumpContent += `-- Generated by: CPLP-Raras Backup Script\n\n`;
        
        dumpContent += `SET NAMES utf8mb4;\n`;
        dumpContent += `SET FOREIGN_KEY_CHECKS = 0;\n\n`;
        
        console.log(`ğŸ“‹ Processando ${tables.length} tabelas...`);
        
        for (const table of tables) {
            const tableName = Object.values(table)[0];
            
            try {
                console.log(`   ğŸ“Š Processando: ${tableName}`);
                
                // Obter estrutura da tabela
                const [createTable] = await connection.query(`SHOW CREATE TABLE \`${tableName}\``);
                const createStatement = createTable[0]['Create Table'];
                
                dumpContent += `-- Estrutura da tabela \`${tableName}\`\n`;
                dumpContent += `DROP TABLE IF EXISTS \`${tableName}\`;\n`;
                dumpContent += createStatement + ';\n\n';
                
                // Obter dados da tabela
                const [rows] = await connection.query(`SELECT * FROM \`${tableName}\``);
                
                if (rows.length > 0) {
                    dumpContent += `-- Dados da tabela \`${tableName}\`\n`;
                    
                    // Processar em lotes de 1000 registros
                    const batchSize = 1000;
                    for (let i = 0; i < rows.length; i += batchSize) {
                        const batch = rows.slice(i, i + batchSize);
                        
                        if (batch.length > 0) {
                            const columns = Object.keys(batch[0]);
                            const columnsList = columns.map(col => `\`${col}\``).join(', ');
                            
                            const values = batch.map(row => {
                                const rowValues = columns.map(col => {
                                    const value = row[col];
                                    if (value === null) return 'NULL';
                                    if (typeof value === 'string') {
                                        return `'${value.replace(/'/g, "''")}'`;
                                    }
                                    if (value instanceof Date) {
                                        return `'${value.toISOString().slice(0, 19).replace('T', ' ')}'`;
                                    }
                                    return value;
                                }).join(', ');
                                return `(${rowValues})`;
                            });
                            
                            dumpContent += `INSERT INTO \`${tableName}\` (${columnsList}) VALUES\n`;
                            dumpContent += values.join(',\n') + ';\n\n';
                        }
                    }
                    
                    console.log(`      âœ… ${rows.length.toLocaleString()} registros exportados`);
                } else {
                    console.log(`      âšª Tabela vazia`);
                }
                
            } catch (err) {
                console.log(`      âŒ Erro ao processar ${tableName}: ${err.message}`);
                dumpContent += `-- ERRO ao processar tabela ${tableName}: ${err.message}\n\n`;
            }
        }
        
        dumpContent += `SET FOREIGN_KEY_CHECKS = 1;\n`;
        
        // Salvar arquivo
        fs.writeFileSync(outputPath, dumpContent, 'utf8');
        
        const stats = fs.statSync(outputPath);
        console.log(`âœ… Dump criado com sucesso!`);
        console.log(`ğŸ“ Arquivo: ${outputPath}`);
        console.log(`ğŸ“Š Tamanho: ${(stats.size / 1024 / 1024).toFixed(2)} MB`);
        
        return outputPath;
        
    } catch (error) {
        console.error(`âŒ Erro ao criar dump:`, error.message);
        return null;
    }
}

async function main() {
    console.log('ğŸš€ BACKUP COMPLETO DO SERVIDOR MySQL REMOTO');
    console.log('â•'.repeat(80));
    
    let connection;
    
    try {
        // Conectar
        connection = await connectToRemoteServer();
        
        // Listar databases
        const databases = await listDatabases(connection);
        
        // Filtrar databases do sistema
        const systemDatabases = ['information_schema', 'performance_schema', 'mysql', 'sys'];
        const userDatabases = databases.filter(db => !systemDatabases.includes(db));
        
        console.log(`\nğŸ¯ DATABASES DE USUÃRIO: ${userDatabases.length}`);
        userDatabases.forEach(db => console.log(`   ğŸ“¦ ${db}`));
        
        const allResults = [];
        
        // Analisar cada database
        for (const dbName of userDatabases) {
            const result = await analyzeDatabase(connection, dbName);
            allResults.push(result);
            
            // Criar backup se tiver dados
            if (result.totalRecords > 0) {
                const timestamp = new Date().toISOString().slice(0, 10).replace(/-/g, '');
                const backupFileName = `backup_${dbName}_${timestamp}.sql`;
                const backupPath = path.join(__dirname, 'database', backupFileName);
                
                await createMySQLDump(connection, dbName, backupPath);
            }
        }
        
        // RelatÃ³rio final
        console.log('\nğŸ“Š RELATÃ“RIO FINAL DE BACKUP');
        console.log('â•'.repeat(80));
        
        let totalDatabases = allResults.length;
        let totalTables = 0;
        let totalRecords = 0;
        
        allResults.forEach(result => {
            if (!result.error) {
                totalTables += result.tables.length;
                totalRecords += result.totalRecords;
                
                console.log(`\nğŸ—„ï¸  ${result.name}`);
                console.log(`   ğŸ“Š Tabelas: ${result.tables.length}`);
                console.log(`   ğŸ“ˆ Registros: ${result.totalRecords.toLocaleString()}`);
                
                if (result.tables.length > 0) {
                    const topTables = result.tables
                        .filter(t => typeof t.count === 'number')
                        .sort((a, b) => b.count - a.count)
                        .slice(0, 5);
                    
                    console.log('   ğŸ† Top tabelas:');
                    topTables.forEach(table => {
                        console.log(`      â€¢ ${table.name}: ${table.count.toLocaleString()}`);
                    });
                }
            }
        });
        
        console.log('\nğŸ¯ ESTATÃSTICAS GERAIS:');
        console.log(`ğŸ“¦ Databases analisados: ${totalDatabases}`);
        console.log(`ğŸ“Š Total de tabelas: ${totalTables}`);
        console.log(`ğŸ“ˆ Total de registros: ${totalRecords.toLocaleString()}`);
        
    } catch (error) {
        console.error('âŒ Erro durante backup:', error.message);
    } finally {
        if (connection) {
            await connection.end();
            console.log('\nğŸ”Œ ConexÃ£o fechada');
        }
    }
}

// Verificar se mysql2 estÃ¡ instalado
try {
    require('mysql2/promise');
    main();
} catch (err) {
    console.log('âŒ MÃ³dulo mysql2 nÃ£o encontrado!');
    console.log('ğŸ’¡ Execute: npm install mysql2');
    console.log('   Depois execute novamente este script.');
}
